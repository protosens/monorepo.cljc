(ns protosens.maestro.uber

  "Special way of merging aliases in a generated `deps.edn` file."

  (:require [babashka.fs               :as bb.fs]
            [clojure.java.io           :as java.io]
            [clojure.pprint            :as pprint]
            [protosens.maestro         :as $.maestro]
            [protosens.maestro.alias   :as $.maestro.alias]
            [protosens.maestro.profile :as $.maestro.profile]))


;;;;;;;;;;


(defn task

  "Generate a single `deps.edn` file by merging everything required by `alias`.

   This is probably only useful in a limited set of dev use cases. One notable
   example is syncing dependencies and paths with [Babashka](https://github.com/babashka/babashka)'s
   `bb.edn` files. One can create:

   - Create an alias in `deps.edn` with a `:maestro/root`, requiring other aliases
   - Run this task on this alias
   - Generated `deps.edn` file in `:maestro/root` will contain all necessary `:deps` and `:paths`
   - Hard links were created for all files found in `:paths`
   - `bb.edn` can use `:local/root` on this

   Hard links are created to allow consuming paths from anywhere in the repository.
   This is because Clojure CLI dislikes outsider paths (e.g. `../foo`)."


  ([alias]

   (task alias 
         nil))


  ([alias basis]

   (let [basis-2     (-> basis
                         ($.maestro/ensure-basis)
                         ($.maestro.alias/append+ [alias])
                         ($.maestro.profile/append+ ['release]))
         alias->data (basis-2 :aliases)
         data        (alias->data alias)
         _           (when-not data
                       (throw (Exception. (str "No data found for alias: "
                                               alias))))
         basis-3     (-> (merge basis-2
                                data)
                         ($.maestro/search))
         required    (basis-3 :maestro/require)
         root        (basis-3 :maestro/root)
         _           (when-not root
                       (throw (Exception. (str "Given alias does not contain `:maestro/root`"))))
         deps-edn    (-> (reduce (fn [deps-edn alias-required]
                                   (let [data-required (alias->data alias-required)]
                                     (-> deps-edn
                                         (update :deps
                                                 merge
                                                 (:extra-deps data-required))
                                         (update :paths
                                                 into
                                                 (:extra-paths data-required)))))
                                 {:deps  {}
                                  :paths #{}}
                                 required)
                         (update :paths
                                 (comp vec
                                       sort)))]
     ;;
     ;; Print `deps.edn` first.
     (with-open [out-deps-edn (java.io/writer (str root
                                                   "/deps.edn"))]
       (binding [*out* out-deps-edn]
         (println ";; This file has been generated by Maestro.")
         (println ";;")
         (println ";; It merges dependencies and paths from a collection of aliases:")
         (println ";;")
         (doseq [alias (sort required)]
           (println ";;    "
                    alias))
         (println ";;")
         (println ";; All files found in those paths are hard links to follow from the")
         (println ";; root of this repository.")
         (println ";;")
         (println ";; This is probably for dev purposes only and should probably never")
         (println ";; be checkout out in version control.")
         (println ";;")
         (pprint/pprint deps-edn)))
     ;;
     ;; Create hard links for all files found in merged paths.
     (doseq [path (deps-edn :paths)]
       (doseq [path-child (map str
                               (file-seq (java.io/file path)))
               :when      (not (bb.fs/directory? path-child))
               :let       [path-link (str root
                                          "/"
                                          path-child)]
               :when      (not (bb.fs/exists? path-link))
               :let       [dir (bb.fs/parent path-link)]]
         (when-not (bb.fs/exists? dir)
           (bb.fs/create-dirs dir))
         (println "Link" path-link "->" path-child)
         (bb.fs/create-link path-link
                            path-child)))
     nil)))
