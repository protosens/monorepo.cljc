(ns protosens.deps.edn

  "Specialized functions for handling `deps.edn` files.
  
   Most useful for tool authors. [[read]] fetches a `deps.edn` file and other functions
   are used for extracting informations."

  (:refer-clojure :exclude [read])
  (:require [protosens.edn.read  :as $.edn.read]
            [protosens.namespace :as $.namespace]))


(declare path+)


(set! *warn-on-reflection*
      true)


;;;;;;;;;; IO


(defn read 

  "Reads the `deps.edn` file located in `dir`.
  
   Defaults to `./`.
  
   Remembers the `dir`ectory under `:deps/root`.
  
   Typically, an entry point for using other functions from this namespace."


  ([]

   (read nil))


  ([dir]

   (-> (str (or dir
                ".")
            "/deps.edn")
       ($.edn.read/file)
       (assoc :deps/root
              dir))))


;;;;;;;;;; Private


(defn- -prepend-root

  ;; Prepends `:deps/root` to paths.

  [deps-edn path+]

  (let [root (deps-edn :deps/root)]
    (cond->>
      path+
      root
      (map (fn [path]
             (str root
                  "/"
                  path))))))


;;;;;;;;;; Extracting information from `deps.edn` files


(defn extra-path+

  "Returns all `:extra-paths` from the given aliases.

   Prepends them prepended with `:deps/root`."

  [deps-edn alias+]

  (-prepend-root deps-edn
                 (mapcat (comp :extra-paths
                               (deps-edn :aliases))
                         alias+)))



(defn namespace+

  "Returns namespaces provided by source files in that `deps.edn`.
  
   Options may be:

   | Key           | Value                  | Default                          |
   |---------------|------------------------|----------------------------------|
   | `:alias+`     | See [[path+]]          | `nil`                            |
   | `:extension+` | Source file extensions | `[\".clj\" \".cljc\" \".cljs\"]` |"


  ([deps-edn]

   (namespace+ deps-edn
               nil))


  ([deps-edn option+]

   (-> deps-edn
       (path+ (:alias+ option+))
       ($.namespace/in-path+ option+))))



(defn path+

  "Returns all `:paths` and `:extra-paths` for the given aliases.

   Prepends them prepended with `:deps/root`."


  ([deps-edn]

   (path+ deps-edn
          nil))


  ([deps-edn alias+]

   (concat (-prepend-root deps-edn
                          (deps-edn :paths))
           (extra-path+ deps-edn
                        alias+))))


;;;;;;;;;; High-level tooling


(defn main-ns

  "Pretty-prints to `*out*` a CLJC namespace requiring all namespaces provided by `deps.edn`.

   Namespace is named after `ns-sym`.
   Pure CLJ or pure CLJS required namespaces are guarded by reader conditionals.

   Aliases to activate may be provided in `option+` under `:alias+`.

   Also see [[namespace+]]."


  ([deps-edn ns-sym]

   (main-ns deps-edn
            ns-sym
            nil))


  ([deps-edn ns-sym option+]

   (println ";; This file has been autogenerated.")
   (println ";; Its only purpose is to require a collection of namespaces.")
   (println ";;")
   (println ";;")
   (print "(ns ")
   (binding [*print-meta* true]
     (prn (with-meta ns-sym
                     {:no-doc true})))
   (println "  (:require")
   (doseq [sym   (sort (namespace+ deps-edn
                                   option+))
           :when (not= sym
                       ns-sym)]
     (print "    ")
     (println (case (:protosens.namespace/extension (meta sym))
                ".clj"  (format "#?(:clj %s)"
                                sym)
                ".cljc" sym
                ".cljs" (format "#?(:cljs %s)"
                                sym))))
   (println "))")
   (println)
   (println)
   (println ";;;;;;;;;;")
   (println)
   (println)
   (println "(defn -main [& arg+] true)")))
